package org.sm.utilities;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.DumperOptions;
import org.yaml.snakeyaml.Yaml;

import java.io.FileWriter;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;

public class FileUtils {
    private static final Logger LOGGER = LoggerFactory.getLogger(FileUtils.class);

    private FileUtils() {
    }

    /**
     * Reads the contents of a file into a string.
     *
     * @param filePath The path to the file.
     * @return The contents of the file as a string.
     * @throws RuntimeException If the file cannot be read.
     */
    public static String readFileToString(String filePath) {
        try {
            return Files.readString(Paths.get(filePath));
        } catch (IOException e) {
            LOGGER.error(String.format("File '%s' was not found.", filePath));
            throw new RuntimeException(e);
        }
    }

    /**
     * Writes a string to a file.
     *
     * @param content  The content to write to the file.
     * @param filePath The path to the file.
     * @throws RuntimeException If the file cannot be written.
     */
    public static void writeStringToFile(String content, String filePath) {
        ExceptionUtils.logErrorAndThrowIfNull(LOGGER, "Content to write", content);

        try {
            // Ensure the directory exists
            Path path = Paths.get(filePath);
            Files.createDirectories(path.getParent());

            // Write
            Files.writeString(path, content);
            LOGGER.info("Successfully wrote to the file '{}'.", filePath);
        } catch (IOException e) {
            LOGGER.error(String.format("Failed to write to the file '%s'.", filePath), e);
            throw new RuntimeException(e);
        }
    }

    /**
     * Writes the provided map data to a YAML file at the specified file path. This method ensures that the
     * directory structure for the given file path exists before writing the file. The YAML content is written
     * using block style formatting for better readability.
     *
     * @param data     The map containing the data to be written to the YAML file. The map should have string keys
     *                 and object values that are serializable to YAML.
     * @param filePath The file path where the YAML content will be written. If the file already exists, it will be
     *                 overwritten. If the file does not exist, it will be created along with any necessary parent directories.
     * @throws RuntimeException If an I/O error occurs during writing to the file. The original {@link IOException} is
     *                          included as the cause of the thrown {@link RuntimeException}.
     * @author Andrei Goriunov (Andrei.Goriunov@ey.com)
     */
    public static synchronized void writeMapToYamlFile(Map<String, Object> data, String filePath) {
        try {
            // Ensure the directory exists
            Path path = Paths.get(filePath);
            Files.createDirectories(path.getParent());

            // Yaml config options
            DumperOptions options = new DumperOptions();
            options.setDefaultFlowStyle(DumperOptions.FlowStyle.BLOCK); // Use block style
            options.setPrettyFlow(true);
            Yaml yaml = new Yaml(options);

            // Write
            FileWriter writer = new FileWriter(path.toFile());
            yaml.dump(data, writer);
            writer.close(); // Ensure the writer is properly closed after writing
            LOGGER.info("Successfully wrote to the file '{}'", filePath);
        } catch (IOException e) {
            LOGGER.error("Failed to write Map to yaml file.", e);
            throw new RuntimeException("Failed to write Map to yaml file.", e);
        }
    }

    /**
     * Appends data to a YAML file associated with a specific key. If the key already exists and the
     * {@code overwrite} flag is set to {@code false}, a new unique key is generated by appending "_copy_n" to the original key,
     * where n is a number that ensures the key's uniqueness. If the {@code overwrite} flag is {@code true}, the existing key's
     * data will be overwritten. If the YAML file does not exist, it will be created.
     *
     * @param yamlFilePath The path to the YAML file where the data should be appended.
     * @param key          The key associated with the data to append. If the key already exists and {@code overwrite} is {@code false},
     *                     a unique key will be generated.
     * @param data         The data to append to the YAML file. This data is a map of string keys to object values.
     * @param overwrite    A boolean flag indicating whether to overwrite existing data associated with the key. If {@code true},
     *                     existing data will be overwritten; otherwise, a unique key will be generated if needed.
     * @author Andrei Goriunov (Andrei.Goriunov@ey.com)
     */
    public static void appendToYamlFile(String yamlFilePath, String key, Map<String, Object> data, boolean overwrite) throws IOException {
        ExceptionUtils.logErrorAndThrowIfNull(LOGGER, "Appending Node", key);
        Map<String, Object> existingData =  new YamlReader().getYamlDataFromFile(yamlFilePath);

        // If the file does not exist write the data right away
        if (existingData == null || existingData.isEmpty()) {
            LOGGER.info("The file {} does not exist. A new file will be created.", yamlFilePath);
            writeMapToYamlFile(Map.of(key, data), yamlFilePath);
            return;
        }

        // Check if the environment already exists
        if (!overwrite && existingData.containsKey(key)) {
            LOGGER.info("Key '{}' already exists in the file '{}'.", key, yamlFilePath);
            String uniqueKey = key;
            int copyIndex = 1;
            // If baseKey is "dev", this loop checks for "dev_copy_1", "dev_copy_2", etc.
            while (existingData.containsKey(uniqueKey)) {
                uniqueKey = key + "_copy_" + copyIndex++;
            }
            key = uniqueKey;
            LOGGER.info("Key '{}' will be used instead.", key);
        }

        // Add the new environment data
        existingData.put(key, data);
        // Write the file back
        writeMapToYamlFile(existingData, yamlFilePath);
    }
}
